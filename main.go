package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/binary"
	"errors"
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"sync"
	"time"

	_ "github.com/joho/godotenv/autoload"
	"github.com/schollz/progressbar/v3"
	"golang.org/x/crypto/pbkdf2"
)

var (
	ErrDecryption        = errors.New("decryption error")
	ErrMissingData       = errors.New("missing data")
	ErrBadHeader         = errors.New("data not generated by simplecrypt (bad header)")
	ErrMissingHeader     = errors.New("missing header")
	ErrBadPasswordOrData = errors.New("bad password or corrupt/modified data")
	ErrMissingSalt       = errors.New("missing salt")
	ErrMissingPassword   = errors.New("missing password")
	ErrMessageTooLong    = errors.New("message too long")
)

const AES_KEY_LEN int = 256

const BLOCK_SIZE int = aes.BlockSize

const HALF_BOCK int = BLOCK_SIZE * 8 / 2

const HEADER_LEN int = 4

var HEADER_PREFIX = []byte("sc")

type HEADER_TYPE int

const (
	HEADER_1 HEADER_TYPE = iota
	HEADER_2
	HEADER_3
)

var HEADER_BYTES = map[HEADER_TYPE][]byte{
	HEADER_1: {0x00, 0x00},
	HEADER_2: {0x00, 0x01},
	HEADER_3: {0x00, 0x02},
}

var EXPANSION_COUNT = map[HEADER_TYPE]int{
	HEADER_1: 10000,
	HEADER_2: 10000,
	HEADER_3: 100000,
}

var SALT_LEN = map[HEADER_TYPE]int{
	HEADER_1: 128,
	HEADER_2: 256,
	HEADER_3: 256,
}

// just for completeness I doubt that I will use it
const LATEST_HEADER HEADER_TYPE = HEADER_2

type Config struct {
	Passphrase string
}

// gotta figure this out
var HASH_SIZE = sha256.Size

type TimeHeaderType struct {
	t        time.Duration
	h        HEADER_TYPE
	fileName string
}

type pathPair [2]string

type PathProcessor struct {
	basePath     string
	failedPath   string
	uselessPath  string
	verifiedPath string
	waitingPath  string
}

func (p PathProcessor) generatePaths(channel chan<- pathPair) {
	// it is correct to close the channel here so that no more paths will be appended after this function finishes
	err := filepath.Walk(p.failedPath, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			log.Println(err)
		}
		if p.failedPath == path {
			return nil
		}
		end := filepath.Base(path)
		prefix := path[:len(path)-len(end)]
		decryptedPath := filepath.Join(filepath.Join(prefix, "/decrypted"), end)
		channel <- pathPair{path, decryptedPath}
		return nil

	})
	if err != nil {
		log.Println(err)
	}
	err = filepath.Walk(p.verifiedPath, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			log.Println(err)
		}
		if p.verifiedPath == path {
			return nil
		}
		end := filepath.Base(path)
		prefix := path[:len(path)-len(end)]
		decryptedPath := filepath.Join(filepath.Join(prefix, "/decrypted"), end)
		channel <- pathPair{path, decryptedPath}
		return nil

	})
	if err != nil {
		log.Println(err)
	}
	err = filepath.Walk(p.uselessPath, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			log.Println(err)
		}
		if p.uselessPath == path {
			return nil
		}
		end := filepath.Base(path)
		prefix := path[:len(path)-len(end)]
		decryptedPath := filepath.Join(filepath.Join(prefix, "/decrypted"), end)
		channel <- pathPair{path, decryptedPath}
		return nil

	})
	if err != nil {
		log.Println(err)
	}

	err = filepath.Walk(p.waitingPath, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			log.Println(err)
		}
		if p.waitingPath == path {
			return nil
		}
		end := filepath.Base(path)
		prefix := path[:len(path)-len(end)]
		decryptedPath := filepath.Join(filepath.Join(prefix, "/decrypted"), end)
		channel <- pathPair{path, decryptedPath}
		return nil
	})
	if err != nil {
		log.Println(err)
	}

}

func createPathProcessor(basePath string) PathProcessor {
	return PathProcessor{basePath: basePath, failedPath: filepath.Join(basePath, "/failed"), uselessPath: filepath.Join(basePath, "/useless"), verifiedPath: filepath.Join(basePath, "/verified"), waitingPath: filepath.Join(basePath, "/waiting")}
}

func expand_keys(password string, salt []byte, expansion_count int) ([]byte, []byte) {
	key_len := AES_KEY_LEN / 8
	passwordByte := []byte(password)
	keys := pbkdf2.Key(passwordByte, salt, expansion_count, 2*key_len, sha256.New)
	return keys[:key_len], keys[key_len:]
}

// can also be ignored. this just asserts nobody put a header into the code that is too long or longer than expected
func assertHeaderPrefix(data []byte) error {
	// Equal returns a number
	if len(data) < 2 || !bytes.Equal(data[:2], HEADER_PREFIX) {
		return ErrBadHeader
	}
	return nil
}

func calculateHMAC(key, data []byte) []byte {
	h := hmac.New(sha256.New, key)
	h.Write(data)
	return h.Sum(nil)
}

func assertHMAC(key, hmac1, hmac2 []byte) error {
	// Double HMAC verification to prevent timing attacks
	h1 := calculateHMAC(key, hmac1)
	h2 := calculateHMAC(key, hmac2)

	if !bytes.Equal(h1, h2) {
		return ErrBadPasswordOrData
	}
	return nil
}

func detect_header_version(docBytes []byte) (HEADER_TYPE, error) {
	if assertHeaderPrefix(docBytes) != nil {
		return -1, ErrBadHeader
	}
	if len(docBytes) < HEADER_LEN {
		return -1, ErrBadHeader
	}
	// now I gotta slice the docBytes for the first 4 bytes and then
	// check which
	var header []byte = docBytes[:HEADER_LEN]
	for i, h := range HEADER_BYTES {
		completeHeader := append(HEADER_PREFIX, h...)
		if bytes.Equal(header, completeHeader) {
			return i, nil
		}
	}
	return -1, ErrBadHeader
}

func assert_decrypt_length(data []byte, version HEADER_TYPE) error {
	if len(data) < HEADER_LEN+SALT_LEN[version]/8+HASH_SIZE {
		return ErrDecryption
	}
	return nil

}

func newCTRNonce(prefix []byte) []byte {
	counter := make([]byte, aes.BlockSize)
	copy(counter[:len(prefix)], prefix)
	// Append a 64-bit big-endian counter initialized to 1
	binary.BigEndian.PutUint64(counter[len(prefix):], 1)
	return counter
}

func encrypt(password string, data []byte) ([]byte, error) {
	salt := make([]byte, SALT_LEN[LATEST_HEADER]/8)
	_, err := rand.Read(salt)
	if err != nil {
		log.Fatalf("error while generating random string: %s", err)
	}
	hmacKey, cipherKey := expand_keys(password, salt, EXPANSION_COUNT[LATEST_HEADER])
	block, err := aes.NewCipher(cipherKey)
	if err != nil {
		return nil, err
	}
	//iv := iv(salt[:HALF_BOCK/8])
	// block and counter needs to be the same size
	counter := newCTRNonce(salt[:HALF_BOCK/8])
	stream := cipher.NewCTR(block, counter)
	block, err = aes.NewCipher(cipherKey)
	if err != nil {
		return nil, err
	}

	encrypted := make([]byte, len(data))
	stream.XORKeyStream(encrypted, data)
	header := HEADER_BYTES[LATEST_HEADER]

	var preHmac bytes.Buffer
	preHmac.Write(HEADER_PREFIX)
	preHmac.Write(header)
	preHmac.Write(salt)
	preHmac.Write(encrypted)
	hmac := calculateHMAC(hmacKey, preHmac.Bytes())

	var ciphertext bytes.Buffer
	ciphertext.Write(HEADER_PREFIX)
	ciphertext.Write(header)
	ciphertext.Write(salt)
	ciphertext.Write(encrypted)
	ciphertext.Write(hmac)

	return ciphertext.Bytes(), nil

}

func decrypt(password string, data []byte) ([]byte, HEADER_TYPE, error) {
	// detecting the header version seems to work
	t, err := detect_header_version(data)
	if err != nil {
		log.Println(err)
		return nil, -1, err
	}
	err = assert_decrypt_length(data, t)
	if err != nil {
		log.Println(err)
		return nil, -1, err
	}
	dataMinusHeader := data[HEADER_LEN:]
	salt := dataMinusHeader[:SALT_LEN[t]/8]
	hmacKey, cipherKey := expand_keys(password, salt, EXPANSION_COUNT[t])
	receivedHMAC := dataMinusHeader[len(dataMinusHeader)-sha256.Size:]
	expectedHMAC := calculateHMAC(hmacKey, data[:len(data)-sha256.Size])
	if err := assertHMAC(hmacKey, receivedHMAC, expectedHMAC); err != nil {
		log.Println(err)
		return nil, -1, err
	}
	block, err := aes.NewCipher(cipherKey)

	if err != nil {

		log.Println(err)
		return nil, -1, err
	}
	//iv := iv(salt[:HALF_BOCK/8])
	counter := newCTRNonce(salt[:HALF_BOCK/8])
	stream := cipher.NewCTR(block, counter)
	encryptedData := dataMinusHeader[SALT_LEN[t]/8 : len(dataMinusHeader)-sha256.Size]
	decrypted := make([]byte, len(encryptedData))
	stream.XORKeyStream(decrypted, encryptedData)

	return decrypted, t, nil
}

func ensureDir(filePath string) error {
	dirName := filepath.Dir(filePath)
	if dirName == "." {
		// No directory component, just a filename
		return nil
	}

	// Create all directories in the path if they don't exist
	err := os.MkdirAll(dirName, 0755)
	return err
}

func processFile(p pathPair, passphrase string) (time.Duration, HEADER_TYPE, string, error) {
	path := p[0]
	decryptedPath := p[1]
	data, err := os.ReadFile(path)
	if err != nil {
		log.Printf("Error reading file: %v\n", err)
		return -1, -1, "", nil
	}
	then := time.Now()
	decryptedData, headerType, e := decrypt(passphrase, data)
	elapsed := time.Since(then)

	if e != nil {
		log.Println(e)
	}

	er := ensureDir(decryptedPath)
	if er != nil {
		log.Printf("Failed to create directory structure: %v", err)
		return -1, -1, "", er
	}

	err = os.WriteFile(decryptedPath, decryptedData, 0666)
	if err != nil {
		log.Println(err)
	}

	// delete file
	err = os.Remove(path)
	if err != nil {
		log.Println(err)
	}

	return elapsed, headerType, path, nil
}

func startWork(channel <-chan pathPair, c chan<- TimeHeaderType, waitGroup *sync.WaitGroup, bar *progressbar.ProgressBar, passphrase string) error {
	defer waitGroup.Done()
	for p := range channel {
		fmt.Println(p[0])
		time, headerType, path, err := processFile(p, passphrase)
		if err != nil {
			log.Println(err)
		}
		bar.Add(1)
		c <- TimeHeaderType{time, headerType, path}
	}
	return nil
}

func writePerformance(path string, c <-chan TimeHeaderType, waitGroup *sync.WaitGroup) {
	defer waitGroup.Done()
	file, err := os.Create(path)
	if err != nil {
		log.Fatalln("Could not create file for performance logging")
	}

	defer file.Close()
	for perfTripplet := range c {
		text := fmt.Sprintf(" %f | %d | %s \n", perfTripplet.t.Seconds(), perfTripplet.h, perfTripplet.fileName)
		file.Write([]byte(text))
	}
}

func LoadConfig() (*Config, error) {

	cfg := &Config{
		Passphrase: os.Getenv("PASSPHRASE"),
	}

	return cfg, nil
}

func main() {
	config, _ := LoadConfig()
	var waitGroupPPChannel sync.WaitGroup
	var waitGroupGeneratePaths sync.WaitGroup
	var waitGroupPerformanceChannel sync.WaitGroup
	pPChannel := make(chan pathPair, 100)
	timeHeaderChannel := make(chan TimeHeaderType, 100)

	paths := [5]string{"", "", "", "", ""}
	for _, p := range paths {
		waitGroupGeneratePaths.Add(1)
		go func(path string) {
			defer waitGroupGeneratePaths.Done()
			pP := createPathProcessor(path)
			pP.generatePaths(pPChannel)
		}(p)
	}

	go func() {
		waitGroupGeneratePaths.Wait()
		close(pPChannel)
	}()

	waitGroupPerformanceChannel.Add(1)
	go writePerformance("performance.txt", timeHeaderChannel, &waitGroupPerformanceChannel)
	// start 100 workers
	bar := progressbar.Default(-1, "processing docs")
	for range make([]int, 100) {
		waitGroupPPChannel.Add(1)
		go startWork(pPChannel, timeHeaderChannel, &waitGroupPPChannel, bar, config.Passphrase)
	}
	waitGroupPPChannel.Wait()
	close(timeHeaderChannel)
	waitGroupPerformanceChannel.Wait()
	fmt.Println("Done.")
}
